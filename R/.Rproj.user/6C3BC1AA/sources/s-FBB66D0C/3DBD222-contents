  # igraph version for functional module detection

  # source("./libraryiGraphFunctionalModule.R")
  #
  # library(BioNet)
  # library(igraph)
  # library(dplyr)
  # library(RColorBrewer)
  # #library(fields)
  # library(topGO)

library(scPPIN)

  # 1) Load data
  # 1a) Load biogrid network data
  biogridNetwork <- read_graph('biogridHomoSapiens3.5.166.graphml', format='graphml')

  # 1b) Load gene expression data (in the form of p-values)
  #readGenes = read.csv("./../../data/singleCellGeneExpression/DEG_in_hepatocytes_clusters_nofilter_logfc.csv")
  readGenesRDS <- readRDS("./../../data/singleCellGeneExpression/cluster_vs_cluster_DEG_version2_demuxlet.RDS")

  #geneData = data.frame(readGenes)
  #geneData <- geneData[,c("symbol","FS_vs_BS_pvalue","DS_vs_BS_pvalue","DFS_vs_BS_pvalue")] # select only the columns of interest
  geneData <- readGenesRDS[,c("p_val","avg_logFC","pct.1","pct.2","p_val_adj","ident.1_vs_ident.2","symbol")] # select only the columns of interest
  #geneData <- readGenesRDS[,c("p_val","ident.1_vs_ident.2","symbol")] # select only the columns of interest



  indecesInterested <- which(geneData[6] == "Cluster_Number_1_vs_6")



  #geneAsList <- lapply(split(geneData,geneData$symbol), function(x) as.list(x))

  #geneAsList <- as.list(geneData[,c(2,3)])


  # a) for monolayer version
  geneAsList <- as.list(as.data.frame(t(geneData[indecesInterested,c(1)])))
  names(geneAsList) <- geneData[indecesInterested,]$symbol
  geneAsList <- unlist(geneAsList)


  # TODO: allow other genes with p-value 1!


  # b) for multilayer version
  #geneAsListML <- as.list(as.data.frame(t(geneData[c(2,3)])))
  #names(geneAsListML) <- geneData$symbol

  #geneAsListML <- as.list(as.data.frame(geneData[c(2,3)]))
  #names(geneAsListML[[1]]) <- geneData$symbol
  #names(geneAsListML[[2]]) <- geneData$symbol


  #geneData[indecesInterested,5]

  geneSubset <- intersect(V(biogridNetwork)$name,names(geneAsList) )



  # 2) Construct node-weighted network
  biogridNetworkFiltered <- induced_subgraph(biogridNetwork,  geneSubset)
#  indexTemp = match(geneAsList,V(biogridNetworkFiltered)$name)
  indexTemp = match(names(geneAsList),geneSubset)
   # a) in a monloayer version (only overexpression)
  biogridNetworkNodeWeighted <- set_vertex_attr(biogridNetworkFiltered, "pVal",indexTemp[is.finite(indexTemp )], geneAsList[is.finite(indexTemp )] )
  #biogridNetworkNodeWeighted<- delete_vertices(biogridNetworkNodeWeighted, which(lengths(V(biogridNetworkNodeWeighted)$pVal)==0))
  biogridNetworkNodeWeighted <- delete_vertices(biogridNetworkNodeWeighted, which(is.na(V(biogridNetworkNodeWeighted)$pVal)))


  # b) in a multilayer version
  #biogridNetworkNodeWeightedML<- set_vertex_attr(biogridNetworkFiltered, "pVal",indexTemp[is.finite(indexTemp )], geneAsListML[is.finite(indexTemp)][1] )
  #biogridNetworkNodeWeightedML<- delete_vertices(biogridNetworkNodeWeightedML, which(lengths(V(biogridNetworkNodeWeightedML)$pVal)==0))

  # ### MONOLAYER VERSION
  # 3) Run the analysis to find the maximal node-weighted spanning tree
  FDR <- 10^(-2) # set false discovery rate
  extraTreeCost <- 1000 # the cost for having an additional tree
  outputList <- detectFunctionalModuleMonolayer(biogridNetworkNodeWeighted,FDR,extraTreeCost)
  activeModules <- outputList[[1]]
  activeModulesScores<- outputList[[2]]

  # 4) Visualise the output
  activeSubgraph <- induced_subgraph(biogridNetworkNodeWeighted, activeModules)
  #d = activeModulesScores
  #cols=setNames(colorRampPalette(c("blue", "orange"))(length(unique(d))),unique(d))

  scaledActiveModulesScores = (activeModulesScores - mean(activeModulesScores))


  pal <- brewer.pal(11, "PRGn")
  col <- map2color(scaledActiveModulesScores,pal)

  pal <- brewer.pal(11, "PRGn")
  pValuesSubgraph <- log10(geneAsList[V(activeSubgraph)$name])
  colSubgraph <- map2color(pValuesSubgraph,pal)

  #plot(activeSubgraph,layout=layout.fruchterman.reingold,vertex.color=cols,vertex.label.dist=2.5)
  #plot(activeSubgraph,layout=layout.fruchterman.reingold,vertex.label.dist=2.5,vertex.color = pal[as.numeric(as.factor(activeModulesScores))])
  #plot(activeSubgraph,layout=layout.fruchterman.reingold,vertex.label.dist=2.5)

plot(activeSubgraph,layout=layout.fruchterman.reingold,vertex.label.dist=2.5,vertex.color = pal[as.numeric(as.factor(colSubgraph))])

  # adjust size
  V(activeSubgraph)$size=sqrt(degree(activeSubgraph))*5

  plot(activeSubgraph,layout=layout.fruchterman.reingold,vertex.label.dist=1.5,vertex.color = colSubgraph)
  #title(paste('active module in fatty acid condition',' FDR=', toString(FDR)))
  #title(paste('active module in diabetic condition',' FDR=', toString(FDR)))
  #title(paste('active module in fatty acid  & diabetic condition',' FDR=', toString(FDR)))


  cbarLocation=c(-1,-0.5)

# GO analysis

  # geneList <- factor(as.integer(geneSubset %in% names(V(activeSubgraph))))
  # names(geneList) <- names(V(biogridNetworkNodeWeighted))
  #
  # sigLevel <-0.01
  #
  # # set up the GO DAG
  # GOdata <- new("topGOdata",
  #               ontology = "BP",
  #               allGenes = geneList,
  #               nodeSize = 5,
  #               annot = annFUN.org,
  #               mapping = "org.Hs.eg.db",
  #               ID = "symbol")
  #
  #
  #
  # resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher")
  # scoreTemp <- score
  # GenTable(GOdata,resultFisher, topNodes = 20)
  # plot.new()
  # showSigOfNodes(GOdata, score(resultFisher), firstSigNodes = 10, useInfo = 'def')
  # sum(scoreTemp(resultFisher)<sigLevel)
  # sigPIN <- scoreTemp(resultFisher)<sigLevel
  #
  # # GO analysis of all significant genes (without the PIN):
  # #geneList <- factor(as.integer(geneSubset %in% names(V(activeSubgraph))))
  #
  # topDiffGenes <-
  # function (allScore)
  # {
  #   return(allScore < FDR)
  # }
  #
  # GOdataExpression <- new("topGOdata",
  #               ontology = "BP",
  #               allGenes = geneAsList,
  #               geneSelectionFun = topDiffGenes,
  #               nodeSize = 5,
  #               annot = annFUN.org,
  #               mapping = "org.Hs.eg.db",
  #               ID = "symbol")
  #
  # resultFisherExpression <- runTest(GOdataExpression, algorithm = "classic", statistic = "fisher")
  # GenTable(GOdataExpression,resultFisherExpression, topNodes = 20)
  # sum(score(resultFisherExpression)<sigLevel)
  #
  # intersect(names(which(sigPIN)),names(which(score(resultFisherExpression)<sigLevel)))
  #
  #
  # intersect(names(which(geneAsList<FDR)),names(V(activeSubgraph)))
